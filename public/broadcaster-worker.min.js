new class{constructor(){this.queueTimeout=1e3,self.onmessage=this.handleMessage.bind(this),this.queuedMessages=[],this.queueTimer=null,this.inboxes=[],this.db=null,this.fallbackReplies=[],this.dbUid=this.uid();const e=indexedDB.open(""+this.dbUid,1);e.onsuccess=()=>{this.sendReadyMessage()},e.onerror=()=>{console.warn("Failed to create database, using array fallback."),this.sendReadyMessage()},e.onupgradeneeded=e=>{const s=e.target;this.db=s.result;const t=this.db.createObjectStore("history",{autoIncrement:!0});t.createIndex("messageUid","messageUid",{unique:!1}),t.createIndex("recipient","recipient",{unique:!1}),t.createIndex("senderId","senderId",{unique:!1}),t.createIndex("attempt","attempt",{unique:!1}),t.createIndex("data","data",{unique:!1});const a=this.db.createObjectStore("reply",{autoIncrement:!0});a.createIndex("replyId","replyId",{unique:!0}),a.createIndex("recipient","recipient",{unique:!1}),a.createIndex("senderId","senderId",{unique:!1})}}inbox(e){switch(e.type){case"hookup":this.addInbox(e);break;case"disconnect":this.removeInbox(e);break;case"update-addresses":this.updateAddressIndexes(e);break;case"init":this.handleUserDeviceInfo(e);break;case"unload":this.db&&indexedDB.deleteDatabase(this.dbUid);break;default:console.error("Unknown broadcast-worker message type: "+e.type)}}handleMessage(e){const{recipient:s,data:t}=e.data;switch(s){case"broadcast-worker":this.inbox(t);break;case"broadcaster":self.postMessage(e.data);break;default:this.lookup(e.data)}}sendReadyMessage(){self.postMessage({recipient:"broadcaster",data:{type:"worker-ready"}})}lookupReply(e){return new Promise(s=>{if(this.db)this.db.transaction("reply","readonly").objectStore("reply").index("replyId").get(e.replyId).onsuccess=e=>{s(e.target.result)};else for(let t=0;t<this.fallbackReplies.length;t++)if(this.fallbackReplies[t].replyId===e.replyId){s(this.fallbackReplies[t]);break}})}uid(){return new Array(4).fill(0).map(()=>Math.floor(Math.random()*Number.MAX_SAFE_INTEGER).toString(16)).join("-")}addInbox(e){const{name:s,inboxAddress:t,uid:a}=e,i={name:s.trim().toLowerCase(),address:t,uid:a};this.inboxes.push(i)}removeInbox(e){const{inboxAddress:s}=e;for(let e=this.inboxes.length-1;e>=0;e--)if(this.inboxes[e].address===s){this.inboxes.splice(e,1);break}}updateAddressIndexes(e){const{addresses:s}=e;for(let e=0;e<s.length;e++)for(let t=0;t<this.inboxes.length;t++)if(s[e].oldAddressIndex===this.inboxes[e].address){this.inboxes[e].address=s[e].newAddressIndex;break}self.postMessage({recipient:"broadcaster",data:{type:"cleanup-complete"}})}async makeHistory(e){this.db&&new Promise((s,t)=>{var a;const i=this.db.transaction("history","readwrite"),r=i.objectStore("history"),d={senderId:null==e?void 0:e.senderId,messageUid:null==e?void 0:e.messageId,recipient:null===(a=null==e?void 0:e.recipient)||void 0===a?void 0:a.trim().toLowerCase(),data:null==e?void 0:e.data,attempt:null==e?void 0:e.attempts};r.add(d),i.oncomplete=s,i.onerror=t}).then(()=>{}).catch(e=>{console.error("Failed to write to the History table:",e)})}async logReply(e,s=null,t=null){if(this.db)new Promise((a,i)=>{const r=this.db.transaction("reply","readwrite"),d=r.objectStore("reply"),n={replyId:e,recipient:s,senderId:t};d.add(n),r.oncomplete=a,r.onerror=i}).then(()=>{}).catch(e=>{console.error("Failed to write to the Reply table:",e)});else{const a={replyId:e,recipient:s,senderId:t};this.fallbackReplies.push(a)}}async lookup(e){this.makeHistory(e);const s=[];let t=null;if(null==e?void 0:e.replyId){const a=await this.lookupReply(e);for(let e=0;e<this.inboxes.length;e++){const t=this.inboxes[e];t.uid===a.senderId&&s.push(t.address)}(null==e?void 0:e.replyAll)&&(t=a.recipient)}if((null==e?void 0:e.recipient)&&(t=e.recipient.trim().toLowerCase()),t)for(let e=0;e<this.inboxes.length;e++){const a=this.inboxes[e];a.name===t&&s.push(a.address)}if(s.length){const a={type:"lookup",data:e.data,inboxIndexes:s};if((null==e?void 0:e.type)&&(a.data.type=e.type),null==e?void 0:e.senderId){const s=this.uid();a.data.replyId=s,this.logReply(s,t,e.senderId)}self.postMessage(a),(null==e?void 0:e.attempts)&&this.dropMessageFromQueue(e.messageId)}else e.maxAttempts>1&&((null==e?void 0:e.attempts)<e.maxAttempts?e.attempts+=1:(null==e?void 0:e.attempts)===e.maxAttempts?this.dropMessageFromQueue(e.messageId):(e.attempts=1,this.queuedMessages.push(e),null===this.queueTimer&&(this.queueTimer=setTimeout(this.flushMessageQueue.bind(this),this.queueTimeout))))}flushMessageQueue(){for(let e=0;e<this.queuedMessages.length;e++)this.lookup(this.queuedMessages[e]);this.queuedMessages.length?this.queueTimer=setTimeout(this.flushMessageQueue.bind(this),this.queueTimeout):this.queueTimer=null}dropMessageFromQueue(e){for(let s=0;s<this.queuedMessages.length;s++)if(this.queuedMessages[s].messageId===e){this.queuedMessages.splice(s,1);break}}handleUserDeviceInfo(e){const{memory:s,isSafari:t}=e;s<=4?setInterval(()=>{self.postMessage({recipient:"broadcaster",data:{type:"cleanup"}})},6e4):setInterval(()=>{self.postMessage({recipient:"broadcaster",data:{type:"cleanup"}})},3e5),t&&setInterval(()=>{self.postMessage({recipient:"broadcaster",data:{type:"ping"}})},3e3)}generateUUID(){return new Array(4).fill(0).map(()=>Math.floor(Math.random()*Number.MAX_SAFE_INTEGER).toString(16)).join("-")}};